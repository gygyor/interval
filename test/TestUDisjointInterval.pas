unit TestUDisjointInterval;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, UAvlTree, SysUtils, UDisjointInterval;

type
  // Test methods for class TDisjointIntervals

  TestTDisjointIntervals = class(TTestCase)
  strict private
    FDisjointIntervals: TDisjointIntervals<string>;
  protected
    procedure OnMerge(const Intervals: TIntervalList<string>; var NewData: string);
    procedure OnSplit(const Interval1, Interval2: TIntervalConflictResolution<string>);
  public
    procedure SetUp; override;
    procedure TearDown; override;

    procedure Print;
    procedure CheckIntervals(Enumerator: TIntervalIterator<string>; Start, Close: Integer); overload;
    procedure CheckIntervals(Enumerator: TIntervalIterator<string>; Start, Close: Integer; Data: string); overload;
  published
    procedure TestAdd;
    procedure TestRemove;
    procedure TestIsPointIn;
    procedure TestGetIntervalAt;
    procedure TestMinMax;
  end;

implementation

procedure TestTDisjointIntervals.CheckIntervals(Enumerator: TIntervalIterator<string>; Start,
  Close: Integer; Data: string);
begin
  CheckTrue(Enumerator.MoveNext);
  CheckEquals(Enumerator.Current.Start, Start);
  CheckEquals(Enumerator.Current.Close, Close);
  CheckEquals(Enumerator.Current.Data, Data);
end;

procedure TestTDisjointIntervals.CheckIntervals(Enumerator: TIntervalIterator<string>; Start,
  Close: Integer);
begin
  CheckTrue(Enumerator.MoveNext);
  CheckEquals(Enumerator.Current.Start, Start);
  CheckEquals(Enumerator.Current.Close, Close);
end;

procedure TestTDisjointIntervals.OnMerge(const Intervals: TIntervalList<string>;
  var NewData: string);
var
  i: TInterval<string>;
begin
  NewData := '';
  for i in Intervals do
  begin
    if NewData = '' then
    begin
      NewData := i.Data;
      Continue;
    end;

    NewData := NewData + ', ' + i.Data;
  end;
end;

procedure TestTDisjointIntervals.OnSplit(const Interval1,
  Interval2: TIntervalConflictResolution<string>);
begin
  Interval1.NewData := Interval1.NewData + '1';
  Interval2.NewData := Interval2.NewData + '2';
end;

procedure TestTDisjointIntervals.Print;
var
  i: TInterval<string>;
begin
  for i in FDisjointIntervals do
  begin
    Status(Format('%d - %d - %s', [i.Start, i.Close, i.Data]));
  end;
end;

procedure TestTDisjointIntervals.SetUp;
begin
  FDisjointIntervals := TDisjointIntervals<string>.Create;
  FDisjointIntervals.OnMerge := OnMerge;
  FDisjointIntervals.OnSplit := OnSplit;
end;

procedure TestTDisjointIntervals.TearDown;
begin
  FDisjointIntervals.Free;
  FDisjointIntervals := nil;
end;

procedure TestTDisjointIntervals.TestAdd;
var
  Enumerator: TIntervalIterator<string>;
begin
  CheckEquals(0, FDisjointIntervals.Count);
  FDisjointIntervals.Add(TInterval<string>.Create(1, 10, 'x'));
  CheckEquals(1, FDisjointIntervals.Count);
  FDisjointIntervals.Add(TInterval<string>.Create(1, 10, 'y'));
  FDisjointIntervals.Add(TInterval<string>.Create(2, 3, 'z'));
  CheckEquals(1, FDisjointIntervals.Count);
  FDisjointIntervals.Add(TInterval<string>.Create(13, 14, 'za'));
  FDisjointIntervals.Add(TInterval<string>.Create(14, 15, 'zb'));
  CheckEquals(2, FDisjointIntervals.Count);

  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 10, 'x, y, z');
    CheckIntervals(Enumerator, 13, 15, 'za, zb');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Add(TInterval<string>.Create(3, 16, 'zc'));
  CheckEquals(1, FDisjointIntervals.Count);

  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 16, 'x, y, z, za, zb, zc');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Clear;
  FDisjointIntervals.Add(TInterval<string>.Create(1, 3, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(4, 6, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(7, 9, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(2, 8, 'x'));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 9, 'x, x, x, x');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Clear;
  FDisjointIntervals.Add(TInterval<string>.Create(0, 1, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(2, 3, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(5, 6, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(7, 9, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(4, 8, 'x'));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 0, 1, 'x');
    CheckIntervals(Enumerator, 2, 3, 'x');
    CheckIntervals(Enumerator, 4, 9, 'x, x, x');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;
end;

procedure TestTDisjointIntervals.TestGetIntervalAt;
begin
  FDisjointIntervals.Add(TInterval<string>.Create(1, 3, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(4, 6, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(7, 9, 'x'));
  CheckEquals(FDisjointIntervals.GetIntervalAt(5).Close, 6);

  CheckException(
      procedure
      begin
        FDisjointIntervals.GetIntervalAt(6);
      end,
      EIntervalNotFound
    );
end;

procedure TestTDisjointIntervals.TestIsPointIn;
begin
  FDisjointIntervals.Add(TInterval<string>.Create(1, 3, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(5, 6, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(8, 10, 'x'));
  CheckFalse(FDisjointIntervals.IsPointIn(4));
  CheckFalse(FDisjointIntervals.IsPointIn(0));
  CheckTrue(FDisjointIntervals.IsPointIn(1));
  CheckFalse(FDisjointIntervals.IsPointIn(3));
  CheckTrue(FDisjointIntervals.IsPointIn(9));
end;

procedure TestTDisjointIntervals.TestMinMax;
begin
  CheckException(
      procedure
      begin
        FDisjointIntervals.Min;
      end,
      EIntervalNotFound
    );

  FDisjointIntervals.Add(TInterval<string>.Create(1, 3, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(4, 6, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(7, 9, 'x'));

  CheckEquals(FDisjointIntervals.Min.Start, 1);
  CheckEquals(FDisjointIntervals.Max.Start, 7);
  CheckEquals(FDisjointIntervals.Max.Close, 9);
end;

procedure TestTDisjointIntervals.TestRemove;
var
  Enumerator: TIntervalIterator<string>;
begin
  FDisjointIntervals.Add(TInterval<string>.Create(1, 3, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(4, 6, 'x'));
  FDisjointIntervals.Add(TInterval<string>.Create(7, 9, 'x'));

  FDisjointIntervals.Remove(TInterval<string>.Create(3, 4));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 3, 'x');
    CheckIntervals(Enumerator, 4, 6, 'x');
    CheckIntervals(Enumerator, 7, 9, 'x');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Remove(TInterval<string>.Create(2, 8));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 2, 'x');
    CheckIntervals(Enumerator, 8, 9, 'x');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Add(TInterval<string>.Create(2, 8, 'y'));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 9, 'x, x, y');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Remove(TInterval<string>.Create(2, 8));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 1, 2, 'x, x, y1');
    CheckIntervals(Enumerator, 8, 9, 'x, x, y2');
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;

  FDisjointIntervals.Add(TInterval<string>.Create(0, 10, 'x'));
  FDisjointIntervals.Remove(TInterval<string>.Create(5, 20));
  Enumerator := FDisjointIntervals.GetEnumerator;
  try
    CheckIntervals(Enumerator, 0, 5);
    CheckFalse(Enumerator.MoveNext);
  finally
    FreeAndNil(Enumerator);
  end;
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(TestTDisjointIntervals.Suite);
end.

